library(tidyverse)
library(tidymodels)
library(rsample)
library(ggplot2)
library(GGally)
datos_properati <- read.csv("properati_preprocesado.csv")
glimpse(datos_properati)
datos_properati %>%
head()
# graficamos con ggpairs coloreando por property type
g <- ggpairs(datos_properati %>% select(-c(id,l3)), aes(color = property_type),
upper = list(continuous = wrap("cor", size = 3, hjust=0.5)), legend = 25) +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
theme_bw()
# hacemos un loop para cambiar los colores del gráfico
for(i in 1:g$nrow) {
for(j in 1:g$ncol){
g[i,j] <- g[i,j] +
scale_fill_brewer(palette="Dark2") +
scale_color_brewer(palette="Dark2")
}
}
g
# fijamos semilla
set.seed(2021)
# Partición Train y Test, indicando proporción
train_test <- initial_split(datos_properati, prop = 0.75)
train_data <- training(train_test)
test_data <- testing(train_test)
# vemos las dimensiones de cada particion
train_data %>%
dim_desc()
test_data %>%
dim_desc()
# ajustamos modelo lineal multiple
modelo_sc_r <- lm(price ~ surface_covered + rooms, data = train_data)
# Resumen del modelo
tidy_sc_r <- tidy(modelo_sc_r, conf.int = TRUE)
tidy_sc_r
# armamos boxplots paralelos de precio segun el tipo de propiedad (casa, dpto o ph)
ggplot(data = train_data, aes(y = precio_en_miles, group = property_type, fill = property_type)) +
geom_boxplot() +
scale_fill_brewer(palette="Dark2") +
theme_bw() +
theme(axis.text.x=element_blank(),
axis.ticks.x=element_blank()) +
labs(title = "Boxplots de precio según tipo de propiedad", subtitle = "En miles de dólares") +
labs(y = "Precio en miles de USD") +
labs(x = "Tipo de propiedad") +
facet_wrap(~property_type)
# Acotando la escala del grafico para visualizar mejor el rango intercuartil
ggplot(data = train_data, aes(y = precio_en_miles, group = property_type, fill = property_type)) +
geom_boxplot() +
scale_fill_brewer(palette="Dark2") +
theme_bw() +
scale_y_continuous(limits = c(0, 1000)) +
theme(axis.text.x=element_blank(),
axis.ticks.x=element_blank()) +
labs(title = "Boxplots de precio según tipo de propiedad", subtitle = "En miles de dólares") +
labs(y = "Precio en miles de USD") +
labs(x = "Tipo de propiedad") +
facet_wrap(~property_type)
# ajustamos el modelo de superficie y tipo de propiedad
modelo_sc_pt <- lm(price ~ surface_covered + property_type, data = train_data)
tidy_sc_pt <- tidy(modelo_sc_pt, conf.int = TRUE)
tidy_sc_pt
# Accedemos a la información de los coeficientes estimados
intercepto_C = modelo_sc_pt$coefficients[1] # β0
pendiente = modelo_sc_pt$coefficients[2] # β1
intercepto_D = modelo_sc_pt$coefficients[1] + modelo_sc_pt$coefficients[3] # β0 + β2
intercepto_PH = modelo_sc_pt$coefficients[1] + modelo_sc_pt$coefficients[4] # β0 + β3
# Graficamos el dataset y el modelo
train_data %>% ggplot(., aes(x = surface_covered, y = price)) +
geom_abline(intercept = intercepto_C, slope = pendiente, color = "forestgreen", size=1) + # capa del modelo
geom_abline(intercept = intercepto_D, slope = pendiente, color = "darkorange", size=1) + # capa del modelo
geom_abline(intercept = intercepto_PH, slope = pendiente, color = "slateblue3", size=1) + # capa del modelo
geom_point() + #capa de los datos
theme_bw() +
labs(title="Modelo Lineal Múltiple: Superficie y Tipo de Propiedad", x="Superficie en m2", y="Precio en miles de USD")
length(unique(datos_properati$l3)) # 57 barrios
# armo scatterplot de precios en miles en función de superficie total
ggplot( datos_properati, aes(x = fct_reorder(l3, price, .desc = T), y = price/1000)) +
geom_boxplot(alpha = 0.75, aes(fill = l3)) +
theme_minimal() +
theme(legend.position = 'none')+
labs(y = "Precios en miles", x = "Barrios")  +
ggtitle("Boxplots de precios en función de los barrios")+
theme (axis.text.x = element_text(face="italic", colour="dark grey", size = 8, angle = 90))
# ajustamos el modelo
modelo_sc_l3 <- lm(price ~ surface_covered + l3, data = train_data)
tidy_sc_l3 <- tidy(modelo_sc_l3, conf.int = TRUE)
tidy_sc_l3
options("scipen"=1)
tidy_sc_r %>%
select(term, statistic, p.value, conf.low, conf.high)
tidy_sc_pt %>%
select(term, statistic, p.value, conf.low, conf.high)
tidy_sc_l3 %>%
select(term, statistic, p.value, conf.low, conf.high) %>%
arrange(p.value)
# Modelo Superficie Total y Tipo de Propiedad
tidy(anova(modelo_sc_pt))
# Modelo Superficie Total y Barrios
tidy(anova(modelo_sc_l3))
# Creamos una nueva variable  de precios por metro cuadrado
train_data = train_data %>%
mutate(pxm2 = round(price/surface_total,0))
# Armamos un dataframe que muestre los promedios de pxm2 en cada barrio
AVG_pxm2_l3 = train_data %>%
group_by(l3) %>%
summarise(AVG_pxm2_l3 = mean(pxm2))
AVG_pxm2_l3
# boxplot de precios por metro cuadrado
ggplot(data = AVG_pxm2_l3, aes(x = AVG_pxm2_l3)) +
geom_boxplot(alpha = 0.75) +
labs(title = "Boxplot de precios promedio de barrios por m2") +
labs(x = "Precios promedio de barrios por m2")
# armamos nueva variable siguiendo tales criterios
AVG_pxm2_l3 = AVG_pxm2_l3 %>%
mutate(tipo_barrio = case_when(
AVG_pxm2_l3 < quantile(AVG_pxm2_l3)[2] ~ "precio_bajo",
AVG_pxm2_l3 >= quantile(AVG_pxm2_l3)[2] & AVG_pxm2_l3 < quantile(AVG_pxm2_l3)[4] ~ "precio_medio",
TRUE ~ "precio_alto"
)
)
write.csv(AVG_pxm2_l3, 'AVG_pxm2_l3.csv')
# write_csv(AVG_pxm2_l3, 'AVG_pxm2_l3_.csv')
# unimos esta clasificación al dataset original
train_data = train_data %>% left_join(AVG_pxm2_l3, by = 'l3')
head(train_data)
# ajustamos el modelo
modelo_sc_tb <- lm(price ~ surface_covered + tipo_barrio, data = train_data)
tidy_sc_tb <- tidy(modelo_sc_tb, conf.int = TRUE)
tidy_sc_tb
cor(train_data$surface_total, train_data$surface_covered)
modelo_stsc_r_pt <- lm(price ~ surface_total + surface_covered + rooms + property_type, data = train_data)
tidy(modelo_stsc_r_pt)
modelo_stsc <- lm(price ~ surface_total + surface_covered, data = train_data)
tidy(modelo_stsc)
modelo_st_r_pt <- lm(price ~ surface_total + rooms + property_type, data = train_data)
tidy(modelo_st_r_pt)
modelo_sc_r_pt <- lm(price ~ surface_covered + rooms + property_type, data = train_data)
tidy(modelo_sc_r_pt)
df2 = train_data %>%
mutate(surface_uncovered = surface_total - surface_covered)
tidy(lm(price ~ surface_covered + surface_uncovered, data = df2))
tidy_sc_r$estimate[0]
tidy_sc_r$estimate
tidy_sc_r$estimate[1]
tidy_sc_r
round(tidy_sc_r$estimate[1])
tidy_sc_r
# graficamos con ggpairs coloreando por property type
g <- ggpairs(datos_properati %>% select(-c(id,l3)), aes(color = property_type),
upper = list(continuous = wrap("cor", size = 3, hjust=0.5)), legend = 25) +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
theme_bw()
# hacemos un loop para cambiar los colores del gráfico
for(i in 1:g$nrow) {
for(j in 1:g$ncol){
g[i,j] <- g[i,j] +
scale_fill_brewer(palette="Dark2") +
scale_color_brewer(palette="Dark2")
}
}
g
print(g, progress=F)
# graficamos con ggpairs coloreando por property type
g <- ggpairs(datos_properati %>% select(-c(id,l3)), aes(color = property_type),
upper = list(continuous = wrap("cor", size = 3, hjust=0.5)), legend = 25) +
theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.position = "bottom") +
theme_bw()
# hacemos un loop para cambiar los colores del gráfico
for(i in 1:g$nrow) {
for(j in 1:g$ncol){
g[i,j] <- g[i,j] +
scale_fill_brewer(palette="Dark2") +
scale_color_brewer(palette="Dark2")
}
}
print(g, progress=F) # no progress bar
# Accedemos a la información de los coeficientes estimados
intercepto_C = modelo_sc_pt$coefficients[1] # β0
pendiente = modelo_sc_pt$coefficients[2] # β1
intercepto_D = modelo_sc_pt$coefficients[1] + modelo_sc_pt$coefficients[3] # β0 + β2
intercepto_PH = modelo_sc_pt$coefficients[1] + modelo_sc_pt$coefficients[4] # β0 + β3
# Graficamos el dataset y el modelo
train_data %>% ggplot(., aes(x = surface_covered, y = price)) +
geom_point() + #capa de los datos
geom_abline(intercept = intercepto_C, slope = pendiente, color = "forestgreen", size=1) + # capa del modelo
geom_abline(intercept = intercepto_D, slope = pendiente, color = "darkorange", size=1) + # capa del modelo
geom_abline(intercept = intercepto_PH, slope = pendiente, color = "slateblue3", size=1) + # capa del modelo
theme_bw() +
labs(title="Modelo Lineal Múltiple: Superficie y Tipo de Propiedad", x="Superficie en m2", y="Precio en miles de USD")
# graficamos con ggpairs coloreando por property type
g <- ggpairs(datos_properati %>% select(-c(id,l3)), aes(color = property_type),
upper = list(continuous = wrap("cor", size = 3, hjust=0.5)), legend = 25) +
theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.position = "bottom") +
theme_bw()
# hacemos un loop para cambiar los colores del gráfico
for(i in 1:g$nrow) {
for(j in 1:g$ncol){
g[i,j] <- g[i,j] +
scale_fill_brewer(palette="Dark2") +
scale_color_brewer(palette="Dark2")
}
}
g # no progress bar
length(unique(datos_properati$l3)) # 57 barrios
# armo scatterplot de precios en miles en función de superficie total
ggplot( datos_properati, aes(x = fct_reorder(l3, price, .desc = T), y = price/1000)) +
geom_boxplot(alpha = 0.75, aes(fill = l3)) +
theme_minimal() +
theme(legend.position = 'none')+
labs(y = "Precios en miles", x = "Barrios")  +
ggtitle("Boxplots de precios en función de los barrios")+
theme (axis.text.x = element_text(face="italic", colour="dark grey", size = 8, angle = 90))
# armamos scatterplot de precios en miles en función de superficie total
ggplot(datos_properati, aes(x = fct_reorder(l3, price, .desc = T), y = price/1000)) +
geom_boxplot(alpha = 0.75, aes(fill = l3)) +
theme_minimal() +
theme(legend.position = 'none')+
labs(y = "Precios en miles", x = "Barrios")  +
ylim(0, 2000) +
ggtitle("Boxplots de precios en función de los barrios")+
theme (axis.text.x = element_text(face="italic", colour="dark grey", size = 8, angle = 90))
# armamos scatterplot de precios en miles en función de superficie total
ggplot(datos_properati, aes(x = fct_reorder(l3, price, .desc = T), y = price/1000)) +
geom_boxplot(alpha = 0.75, aes(fill = l3)) +
theme_minimal() +
theme(legend.position = 'none')+
labs(y = "Precios en miles", x = "Barrios")  +
ylim(0, 1200) +
ggtitle("Boxplots de precios en función de los barrios")+
theme (axis.text.x = element_text(face="italic", colour="dark grey", size = 8, angle = 90))
# graficamos con ggpairs coloreando por property type
g <- ggpairs(datos_properati %>% select(-c(id,l3)), aes(color = property_type),
upper = list(continuous = wrap("cor", size = 3, hjust=0.5)), legend = 25) +
theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.position = "bottom") +
theme_bw()
# hacemos un loop para cambiar los colores del gráfico
#for(i in 1:g$nrow) {
#  for(j in 1:g$ncol){
#    g[i,j] <- g[i,j] +
#      scale_fill_brewer(palette="Dark2") +
#      scale_color_brewer(palette="Dark2")
#        }
# }
g
# armamos scatterplot de precios en miles en función de superficie total
ggplot(datos_properati, aes(x = fct_reorder(l3, price, .desc = T), y = price/1000)) +
geom_boxplot(outlier.shape = NA, alpha = 0.75, aes(fill = l3)) +
theme_minimal() +
theme(legend.position = 'none')+
labs(y = "Precios en miles", x = "Barrios")  +
scale_y_continuous(limits = c(lower, upper)) +
ggtitle("Boxplots de precios en función de los barrios")+
theme (axis.text.x = element_text(face="italic", colour="dark grey", size = 8, angle = 90))
# armamos scatterplot de precios en miles en función de superficie total
ggplot(datos_properati, aes(x = fct_reorder(l3, price, .desc = T), y = price/1000)) +
geom_boxplot(outlier.shape = NA, alpha = 0.75, aes(fill = l3)) +
theme_minimal() +
theme(legend.position = 'none')+
labs(y = "Precios en miles", x = "Barrios")  +
scale_y_continuous(limits = c(0, 1200)) +
ggtitle("Boxplots de precios en función de los barrios")+
theme (axis.text.x = element_text(face="italic", colour="dark grey", size = 8, angle = 90))
# armamos scatterplot de precios en miles en función de superficie total
ggplot(datos_properati, aes(x = fct_reorder(l3, price, .desc = T), y = price/1000)) +
geom_boxplot(outlier.shape = NA, alpha = 0.75, aes(fill = l3)) +
theme_minimal() +
theme(legend.position = 'none')+
labs(y = "Precios en miles", x = "Barrios")  +
scale_y_continuous(limits = c(0, 1200)) +
ggtitle("Boxplots de precios en función de los barrios")+
theme (axis.text.x = element_text(face="italic", colour="dark grey", size = 8, angle = 90))
```{r, fig.width=8, fig.height=5}
# armo scatterplot de precios en miles en función de superficie total
ggplot( datos_properati, aes(x = fct_reorder(l3, price, .desc = T), y = price/1000)) +
geom_boxplot(alpha = 0.75, aes(fill = l3)) +
theme_minimal() +
theme(legend.position = 'none')+
labs(y = "Precios en miles", x = "Barrios")  +
ggtitle("Boxplots de precios en función de los barrios")+
theme (axis.text.x = element_text(face="italic", colour="dark grey", size = 8, angle = 90))
length(unique(datos_properati$l3)) # 57 barrios
# armo scatterplot de precios en miles en función de superficie total
ggplot( datos_properati, aes(x = fct_reorder(l3, price, .desc = T), y = price/1000)) +
geom_boxplot(alpha = 0.75, aes(fill = l3)) +
theme_minimal() +
theme(legend.position = 'none')+
labs(y = "Precios en miles", x = "Barrios")  +
ggtitle("Boxplots de precios en función de los barrios")+
theme (axis.text.x = element_text(face="italic", colour="dark grey", size = 8, angle = 90))
length(unique(datos_properati$l3)) # 57 barrios
# armo scatterplot de precios en miles en función de superficie total
ggplot( datos_properati, aes(x = fct_reorder(l3, price, .desc = T), y = price/1000)) +
geom_boxplot(alpha = 0.75, aes(fill = l3)) +
theme_minimal() +
theme(legend.position = 'none')+
labs(y = "Precios en miles", x = "Barrios")  +
ggtitle("Boxplots de precios en función de los barrios")+
theme (axis.text.x = element_text(face="italic", colour="dark grey", size = 8, angle = 90))
# armamos scatterplot de precios en miles en función de superficie total
ggplot(datos_properati, aes(x = fct_reorder(l3, price, .desc = T), y = price/1000)) +
geom_boxplot(outlier.shape = NA, alpha = 0.75, aes(fill = l3)) +
theme_minimal() +
theme(legend.position = 'none')+
labs(y = "Precios en miles", x = "Barrios")  +
scale_y_continuous(limits = c(0, 1200)) +
ggtitle("Boxplots de precios en función de los barrios")+
theme (axis.text.x = element_text(face="italic", colour="dark grey", size = 8, angle = 90))
# graficamos con ggpairs coloreando por property type
g <- ggpairs(datos_properati %>% select(-c(id,l3)), aes(color = property_type),
upper = list(continuous = wrap("cor", size = 3, hjust=0.5)), legend = 25) +
theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.position = "bottom") +
theme_bw()
# hacemos un loop para cambiar los colores del gráfico
for(i in 1:g$nrow) {
for(j in 1:g$ncol){
g[i,j] <- g[i,j] +
scale_fill_brewer(palette="Dark2") +
scale_color_brewer(palette="Dark2")
}
}
g
# graficamos con ggpairs coloreando por property type
g <- ggpairs(datos_properati %>% select(-c(id,l3)), aes(color = property_type),
upper = list(continuous = wrap("cor", size = 3, hjust=0.5)), legend = 25) +
theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.position = "bottom") +
theme_bw()
# hacemos un loop para cambiar los colores del gráfico
for(i in 1:g$nrow) {
for(j in 1:g$ncol){
g[i,j] <- g[i,j] +
scale_fill_brewer(palette="Dark2") +
scale_color_brewer(palette="Dark2")
}
}
g
# graficamos con ggpairs coloreando por property type
g <- ggpairs(datos_properati %>% select(-c(id,l3)), aes(color = property_type),
upper = list(continuous = wrap("cor", size = 3, hjust=0.5)), legend = 25) +
theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.position = "bottom") +
theme_bw()
# hacemos un loop para cambiar los colores del gráfico
for(i in 1:g$nrow) {
for(j in 1:g$ncol){
g[i,j] <- g[i,j] +
scale_fill_brewer(palette="Dark2") +
scale_color_brewer(palette="Dark2")
}
}
g
